name: Sync VAir & Build

on:
  schedule:
    - cron: '0 0 * * *'
  workflow_dispatch:

env:
  JAVA_VERSION: 17
  TARGET_BRANCH: "main"
  UPSTREAM_URL: "https://github.com/GigaBrawler/Valkyrien-Air.git"
  MOD_PREFIX: "valkyrien-air"
  R2_BUCKET: ${{ secrets.R2_BUCKET_NAME }}
  R2_ACCOUNT_ID: ${{ secrets.R2_ACCOUNT_ID }}
  R2_ACCESS_KEY: ${{ secrets.R2_ACCESS_KEY_ID }}
  R2_SECRET_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}

jobs:
  sync-and-build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          ref: ${{ env.TARGET_BRANCH }}
          fetch-depth: 0

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git remote add upstream ${{ env.UPSTREAM_URL }}
          git fetch upstream

      - name: Check Upstream Changes (Last 24h)
        id: check_update
        run: |
          UPSTREAM_TIME=$(git log -1 --format=%ct upstream/${{ env.TARGET_BRANCH }})
          DAY_AGO=$(date -d "24 hours ago" +%s)
          if [ "$UPSTREAM_TIME" -gt "$DAY_AGO" ]; then
            echo "has_update=true" >> $GITHUB_OUTPUT
          else
            echo "has_update=false" >> $GITHUB_OUTPUT
          fi

      - name: Sync with Upstream (Merge)
        if: steps.check_update.outputs.has_update == 'true'
        run: |
          git merge upstream/${{ env.TARGET_BRANCH }} -m "chore: sync with upstream"

      - name: Setup Java
        if: steps.check_update.outputs.has_update == 'true'
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'temurin'

      - name: Build Mod (No Cache)
        if: steps.check_update.outputs.has_update == 'true'
        run: |
          chmod +x gradlew
          ./gradlew clean build --no-build-cache --no-daemon

      - name: Install Rclone & Configure Env
        if: steps.check_update.outputs.has_update == 'true'
        run: |
          curl -O https://downloads.rclone.org/rclone-current-linux-amd64.zip
          unzip -q rclone-current-linux-amd64.zip
          mv rclone-*-linux-amd64/rclone .
          chmod +x rclone
          
          # 设置环境变量，让 rclone 直接读取，无需生成 config 文件
          export RCLONE_CONFIG_MYR2_TYPE=s3
          export RCLONE_CONFIG_MYR2_PROVIDER=Cloudflare
          export RCLONE_CONFIG_MYR2_ENDPOINT=https://${{ secrets.R2_ACCOUNT_ID }}.r2.cloudflarestorage.com
          export RCLONE_CONFIG_MYR2_ACCESS_KEY_ID=${{ secrets.R2_ACCESS_KEY_ID }}
          export RCLONE_CONFIG_MYR2_SECRET_ACCESS_KEY=${{ secrets.R2_SECRET_ACCESS_KEY }}
          export RCLONE_CONFIG_MYR2_REGION=auto
          export RCLONE_CONFIG_MYR2_ACL=private
          
          echo "✅ Rclone configured via environment variables."
          # 测试连接 (可选，调试用)
          # ./rclone lsd myr2:

      - name: Process and Upload (Overwrite Old)
        if: steps.check_update.outputs.has_update == 'true'
        run: |
          # 必须重新导出变量，因为每个 run 步骤是独立的 shell
          export RCLONE_CONFIG_MYR2_TYPE=s3
          export RCLONE_CONFIG_MYR2_PROVIDER=Cloudflare
          export RCLONE_CONFIG_MYR2_ENDPOINT=https://${{ secrets.R2_ACCOUNT_ID }}.r2.cloudflarestorage.com
          export RCLONE_CONFIG_MYR2_ACCESS_KEY_ID=${{ secrets.R2_ACCESS_KEY_ID }}
          export RCLONE_CONFIG_MYR2_SECRET_ACCESS_KEY=${{ secrets.R2_SECRET_ACCESS_KEY }}
          export RCLONE_CONFIG_MYR2_REGION=auto

          process_and_upload() {
            local src_path="$1"
            local loader="$2" 
            local filename=$(basename "$src_path")
            
            # 1. 过滤
            if [[ "$filename" == *"-dev-shadow"* ]] || [[ "$filename" == *"-sources"* ]]; then
              echo "⏭️ Skip: $filename"
              return
            fi

            # 2. 定义目标名
            local target_name="${MOD_PREFIX}-${loader}.jar"
            # 注意：这里不要加引号包裹整个 remote:path，防止 shell 解析问题
            local remote_dest="myr2:${{ secrets.R2_BUCKET_NAME }}/${target_name}"

            echo "⬆️ Uploading: $filename -> $target_name"
            
            # 3. 执行上传
            # --force: 强制覆盖
            # --transfers=1: 单线程传输更稳定
            # --s3-chunk-size=64M: 适合小文件
            ./rclone copy "$src_path" "$remote_dest" --force --transfers=1 --s3-chunk-size=64M
            
            if [ $? -eq 0 ]; then
              echo "✅ Success: $target_name updated."
            else
              echo "❌ Failed to upload $target_name"
              exit 1
            fi
          }

          if [ -d "build/libs" ]; then
            for f in build/libs/*.jar; do
              [ -e "$f" ] || continue
              # 自动识别 loader
              local loader=""
              if [[ "$f" == *"-forge.jar" ]]; then loader="forge"; fi
              if [[ "$f" == *"-fabric.jar" ]]; then loader="fabric"; fi
              if [ -n "$loader" ]; then
                process_and_upload "$f" "$loader"
              fi
            done
          fi
